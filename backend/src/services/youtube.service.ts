import { spawn } from 'child_process';
import { promisify } from 'util';
import { writeFile, unlink, readFile } from 'fs/promises';
import { tmpdir } from 'os';
import { join } from 'path';
import { randomUUID } from 'crypto';

/**
 * YouTube 자막 추출 및 오디오 다운로드 서비스
 */

interface CaptionTrack {
  baseUrl: string;
  languageCode: string;
  kind?: string; // 'asr' = auto-generated
  name: { simpleText: string };
}

interface TranscriptSegment {
  text: string;
  start: number;
  duration: number;
}

export interface YouTubeTranscript {
  text: string;
  segments: TranscriptSegment[];
  language: string;
  isAutoGenerated: boolean;
}

/**
 * YouTube 영상에서 자막을 추출합니다.
 * @param videoId YouTube 비디오 ID
 * @returns 자막 텍스트와 세그먼트 정보
 */
export async function getTranscript(videoId: string): Promise<YouTubeTranscript> {
  // YouTube 페이지에서 자막 정보 추출
  const videoUrl = `https://www.youtube.com/watch?v=${videoId}`;

  const response = await fetch(videoUrl, {
    headers: {
      'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',
      'Accept-Language': 'ko-KR,ko;q=0.9,en-US;q=0.8,en;q=0.7',
    },
  });

  if (!response.ok) {
    throw new Error(`Failed to fetch YouTube page: ${response.status}`);
  }

  const html = await response.text();

  // ytInitialPlayerResponse에서 자막 정보 추출
  const playerResponseMatch = html.match(/ytInitialPlayerResponse\s*=\s*({.+?});/);
  if (!playerResponseMatch) {
    throw new Error('Could not find player response in YouTube page');
  }

  let playerResponse: any;
  try {
    playerResponse = JSON.parse(playerResponseMatch[1] ?? '{}');
  } catch (e) {
    throw new Error('Failed to parse player response JSON');
  }

  // 자막 트랙 목록 가져오기
  const captionTracks = playerResponse?.captions?.playerCaptionsTracklistRenderer?.captionTracks as CaptionTrack[] | undefined;

  if (!captionTracks || captionTracks.length === 0) {
    throw new Error('NO_CAPTIONS_AVAILABLE');
  }

  // 자막 우선순위: 한국어 수동 → 영어 수동 → 한국어 자동 → 영어 자동 → 기타
  const track = selectBestCaptionTrack(captionTracks);

  if (!track) {
    throw new Error('NO_CAPTIONS_AVAILABLE');
  }

  // 자막 XML 가져오기
  const captionResponse = await fetch(track.baseUrl);
  if (!captionResponse.ok) {
    throw new Error(`Failed to fetch captions: ${captionResponse.status}`);
  }

  const captionXml = await captionResponse.text();
  const segments = parseTranscriptXml(captionXml);

  // 전체 텍스트 생성
  const fullText = segments.map(s => s.text).join(' ');

  return {
    text: fullText,
    segments,
    language: track.languageCode,
    isAutoGenerated: track.kind === 'asr',
  };
}

/**
 * 최적의 자막 트랙을 선택합니다.
 */
function selectBestCaptionTrack(tracks: CaptionTrack[]): CaptionTrack | null {
  // 우선순위 정의
  const priorities = [
    { lang: 'ko', auto: false },  // 한국어 수동
    { lang: 'en', auto: false },  // 영어 수동
    { lang: 'ko', auto: true },   // 한국어 자동
    { lang: 'en', auto: true },   // 영어 자동
  ];

  for (const priority of priorities) {
    const found = tracks.find(t =>
      t.languageCode.startsWith(priority.lang) &&
      (priority.auto ? t.kind === 'asr' : t.kind !== 'asr')
    );
    if (found) return found;
  }

  // 우선순위에 없으면 첫 번째 수동 자막
  const manualTrack = tracks.find(t => t.kind !== 'asr');
  if (manualTrack) return manualTrack;

  // 그래도 없으면 첫 번째 자동 자막
  return tracks[0] || null;
}

/**
 * YouTube 자막 XML을 파싱합니다.
 */
function parseTranscriptXml(xml: string): TranscriptSegment[] {
  const segments: TranscriptSegment[] = [];

  // XML 파싱 (간단한 정규식 사용)
  const textRegex = /<text start="([\d.]+)" dur="([\d.]+)"[^>]*>([^<]*)<\/text>/g;

  let match;
  while ((match = textRegex.exec(xml)) !== null) {
    const startStr = match[1];
    const durationStr = match[2];
    const textStr = match[3];

    if (!startStr || !durationStr || !textStr) continue;

    const start = parseFloat(startStr);
    const duration = parseFloat(durationStr);

    // HTML 엔티티 디코딩
    const text = decodeHtmlEntities(textStr);

    // 빈 텍스트 제외
    if (text.trim()) {
      segments.push({ text: text.trim(), start, duration });
    }
  }

  return segments;
}

/**
 * HTML 엔티티를 디코딩합니다.
 */
function decodeHtmlEntities(text: string): string {
  const entities: Record<string, string> = {
    '&amp;': '&',
    '&lt;': '<',
    '&gt;': '>',
    '&quot;': '"',
    '&#39;': "'",
    '&apos;': "'",
    '&#x27;': "'",
    '&#x2F;': '/',
    '&#32;': ' ',
    '&nbsp;': ' ',
  };

  let result = text;
  for (const [entity, char] of Object.entries(entities)) {
    result = result.replace(new RegExp(entity, 'g'), char);
  }

  // 숫자 엔티티 처리
  result = result.replace(/&#(\d+);/g, (_, num) => String.fromCharCode(parseInt(num, 10)));
  result = result.replace(/&#x([0-9a-fA-F]+);/g, (_, hex) => String.fromCharCode(parseInt(hex, 16)));

  return result;
}

/**
 * 자막 세그먼트를 타임스탬프 포함 마크다운으로 변환합니다.
 */
export function formatTranscriptWithTimestamps(segments: TranscriptSegment[], videoId: string): string {
  const lines: string[] = [];

  // 5분 단위로 그룹화
  const chunkMinutes = 5;
  let currentChunkStart = 0;
  let currentChunkTexts: string[] = [];

  for (const segment of segments) {
    const chunkIndex = Math.floor(segment.start / (chunkMinutes * 60));
    const chunkStart = chunkIndex * chunkMinutes * 60;

    if (chunkStart !== currentChunkStart && currentChunkTexts.length > 0) {
      // 이전 청크 출력
      const timestamp = formatTimestamp(currentChunkStart);
      const youtubeLink = `https://www.youtube.com/watch?v=${videoId}&t=${Math.floor(currentChunkStart)}`;
      lines.push(`\n**[${timestamp}](${youtubeLink})**\n`);
      lines.push(currentChunkTexts.join(' '));
      currentChunkTexts = [];
    }

    currentChunkStart = chunkStart;
    currentChunkTexts.push(segment.text);
  }

  // 마지막 청크 출력
  if (currentChunkTexts.length > 0) {
    const timestamp = formatTimestamp(currentChunkStart);
    const youtubeLink = `https://www.youtube.com/watch?v=${videoId}&t=${Math.floor(currentChunkStart)}`;
    lines.push(`\n**[${timestamp}](${youtubeLink})**\n`);
    lines.push(currentChunkTexts.join(' '));
  }

  return lines.join('\n');
}

/**
 * 초를 타임스탬프 형식으로 변환합니다.
 */
function formatTimestamp(seconds: number): string {
  const hours = Math.floor(seconds / 3600);
  const minutes = Math.floor((seconds % 3600) / 60);
  const secs = Math.floor(seconds % 60);

  if (hours > 0) {
    return `${hours}:${minutes.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
  }
  return `${minutes}:${secs.toString().padStart(2, '0')}`;
}

// ============ Audio Download (yt-dlp) ============

export interface YouTubeAudioResult {
  buffer: Buffer;
  mimeType: string;
  duration?: number;
}

/**
 * yt-dlp를 사용하여 YouTube 오디오를 다운로드합니다.
 * @param videoId YouTube 비디오 ID
 * @returns 오디오 버퍼와 메타데이터
 */
export async function downloadAudio(videoId: string): Promise<YouTubeAudioResult> {
  const url = `https://www.youtube.com/watch?v=${videoId}`;
  const tempId = randomUUID();
  const tempPath = join(tmpdir(), `yt-audio-${tempId}`);
  const outputPath = `${tempPath}.mp3`;

  try {
    // yt-dlp로 오디오 추출 (mp3로 변환)
    await runYtDlp([
      '-x',                           // 오디오만 추출
      '--audio-format', 'mp3',        // mp3로 변환
      '--audio-quality', '0',         // 최고 품질
      '-o', tempPath + '.%(ext)s',    // 출력 경로
      '--no-playlist',                // 플레이리스트 무시
      '--max-filesize', '100M',       // 100MB 제한
      url,
    ]);

    // 파일 읽기
    const buffer = await readFile(outputPath);

    // 임시 파일 삭제
    await unlink(outputPath).catch(() => {});

    return {
      buffer,
      mimeType: 'audio/mpeg',
    };
  } catch (error) {
    // 임시 파일 정리 시도
    await unlink(outputPath).catch(() => {});

    const message = error instanceof Error ? error.message : String(error);

    if (message.includes('not found') || message.includes('ENOENT')) {
      throw new Error('YT_DLP_NOT_INSTALLED');
    }

    throw new Error(`AUDIO_DOWNLOAD_FAILED: ${message}`);
  }
}

/**
 * yt-dlp 명령 실행
 */
function runYtDlp(args: string[]): Promise<string> {
  return new Promise((resolve, reject) => {
    const process = spawn('yt-dlp', args);

    let stdout = '';
    let stderr = '';

    process.stdout.on('data', (data) => {
      stdout += data.toString();
    });

    process.stderr.on('data', (data) => {
      stderr += data.toString();
    });

    process.on('close', (code) => {
      if (code === 0) {
        resolve(stdout);
      } else {
        reject(new Error(stderr || `yt-dlp exited with code ${code}`));
      }
    });

    process.on('error', (err) => {
      reject(err);
    });

    // 10분 타임아웃
    setTimeout(() => {
      process.kill();
      reject(new Error('yt-dlp timeout'));
    }, 10 * 60 * 1000);
  });
}

/**
 * yt-dlp 설치 여부 확인
 */
export async function isYtDlpInstalled(): Promise<boolean> {
  try {
    await runYtDlp(['--version']);
    return true;
  } catch {
    return false;
  }
}
